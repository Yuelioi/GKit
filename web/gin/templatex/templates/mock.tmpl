package {{.Config.Output.Structure.handler}}

import (
	"context"

	"{{.Config.Model.Package}}/models"
	{{if .Config.Features.DTO}}"{{.Config.Model.Package}}/{{.Config.Output.Structure.dto}}"{{end}}
	"github.com/stretchr/testify/mock"
)

{{if .Config.Features.Service}}
// Mock{{.Name}}Service is a mock implementation of {{.Name}}Service for testing
type Mock{{.Name}}Service struct {
	mock.Mock
}

// Create mocks the Create method
func (m *Mock{{.Name}}Service) Create(ctx context.Context, {{if .Config.Features.DTO}}req *dto.Create{{.Name}}Request{{else}}{{.LowerName}} *models.{{.Name}}{{end}}) (*models.{{.Name}}, error) {
	args := m.Called(ctx, {{if .Config.Features.DTO}}req{{else}}{{.LowerName}}{{end}})
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.{{.Name}}), args.Error(1)
}

// GetByID mocks the GetByID method
func (m *Mock{{.Name}}Service) GetByID(ctx context.Context, id uint) (*models.{{.Name}}, error) {
	args := m.Called(ctx, id)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.{{.Name}}), args.Error(1)
}

// List mocks the List method
func (m *Mock{{.Name}}Service) List(ctx context.Context, {{if .Config.Features.DTO}}req *dto.List{{.Name}}Request{{else}}page, pageSize int{{end}}) ([]*models.{{.Name}}, int64, error) {
	args := m.Called(ctx, {{if .Config.Features.DTO}}req{{else}}page, pageSize{{end}})
	if args.Get(0) == nil {
		return nil, 0, args.Error(2)
	}
	return args.Get(0).([]*models.{{.Name}}), args.Get(1).(int64), args.Error(2)
}

// Update mocks the Update method
func (m *Mock{{.Name}}Service) Update(ctx context.Context, id uint, {{if .Config.Features.DTO}}req *dto.Update{{.Name}}Request{{else}}{{.LowerName}} *models.{{.Name}}{{end}}) (*models.{{.Name}}, error) {
	args := m.Called(ctx, id, {{if .Config.Features.DTO}}req{{else}}{{.LowerName}}{{end}})
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.{{.Name}}), args.Error(1)
}

// Delete mocks the Delete method
func (m *Mock{{.Name}}Service) Delete(ctx context.Context, id uint) error {
	args := m.Called(ctx, id)
	return args.Error(0)
}

{{if .Config.Features.Batch}}
// BatchCreate mocks the BatchCreate method
func (m *Mock{{.Name}}Service) BatchCreate(ctx context.Context, {{.LowerName}}s []*models.{{.Name}}) error {
	args := m.Called(ctx, {{.LowerName}}s)
	return args.Error(0)
}

// BatchDelete mocks the BatchDelete method
func (m *Mock{{.Name}}Service) BatchDelete(ctx context.Context, ids []uint) error {
	args := m.Called(ctx, ids)
	return args.Error(0)
}
{{end}}

{{if .Config.Features.Export.Enabled}}
// Export mocks the Export method
func (m *Mock{{.Name}}Service) Export(ctx context.Context, format string) ([]byte, error) {
	args := m.Called(ctx, format)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).([]byte), args.Error(1)
}
{{end}}

{{if .Config.Features.Search}}
// Search mocks the Search method
func (m *Mock{{.Name}}Service) Search(ctx context.Context, keyword string, page, pageSize int) ([]*models.{{.Name}}, int64, error) {
	args := m.Called(ctx, keyword, page, pageSize)
	if args.Get(0) == nil {
		return nil, 0, args.Error(2)
	}
	return args.Get(0).([]*models.{{.Name}}), args.Get(1).(int64), args.Error(2)
}
{{end}}

// NewMock{{.Name}}Service creates a new mock instance
func NewMock{{.Name}}Service() *Mock{{.Name}}Service {
	return &Mock{{.Name}}Service{}
}
{{end}}

{{if .Config.Features.Repository}}
// Mock{{.Name}}Repository is a mock implementation of {{.Name}}Repository for testing
type Mock{{.Name}}Repository struct {
	mock.Mock
}

// Create mocks the Create method
func (m *Mock{{.Name}}Repository) Create(ctx context.Context, {{.LowerName}} *models.{{.Name}}) error {
	args := m.Called(ctx, {{.LowerName}})
	return args.Error(0)
}

// FindByID mocks the FindByID method
func (m *Mock{{.Name}}Repository) FindByID(ctx context.Context, id uint) (*models.{{.Name}}, error) {
	args := m.Called(ctx, id)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.{{.Name}}), args.Error(1)
}

// FindAll mocks the FindAll method
func (m *Mock{{.Name}}Repository) FindAll(ctx context.Context) ([]*models.{{.Name}}, error) {
	args := m.Called(ctx)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).([]*models.{{.Name}}), args.Error(1)
}

// List mocks the List method
func (m *Mock{{.Name}}Repository) List(ctx context.Context, page, pageSize int) ([]*models.{{.Name}}, int64, error) {
	args := m.Called(ctx, page, pageSize)
	if args.Get(0) == nil {
		return nil, 0, args.Error(2)
	}
	return args.Get(0).([]*models.{{.Name}}), args.Get(1).(int64), args.Error(2)
}

// Update mocks the Update method
func (m *Mock{{.Name}}Repository) Update(ctx context.Context, {{.LowerName}} *models.{{.Name}}) error {
	args := m.Called(ctx, {{.LowerName}})
	return args.Error(0)
}

// Delete mocks the Delete method
func (m *Mock{{.Name}}Repository) Delete(ctx context.Context, id uint) error {
	args := m.Called(ctx, id)
	return args.Error(0)
}

{{if .Config.Features.Batch}}
// BatchCreate mocks the BatchCreate method
func (m *Mock{{.Name}}Repository) BatchCreate(ctx context.Context, {{.LowerName}}s []*models.{{.Name}}) error {
	args := m.Called(ctx, {{.LowerName}}s)
	return args.Error(0)
}

// BatchDelete mocks the BatchDelete method
func (m *Mock{{.Name}}Repository) BatchDelete(ctx context.Context, ids []uint) error {
	args := m.Called(ctx, ids)
	return args.Error(0)
}
{{end}}

{{if .Config.Features.Search}}
// Search mocks the Search method
func (m *Mock{{.Name}}Repository) Search(ctx context.Context, keyword string, page, pageSize int) ([]*models.{{.Name}}, int64, error) {
	args := m.Called(ctx, keyword, page, pageSize)
	if args.Get(0) == nil {
		return nil, 0, args.Error(2)
	}
	return args.Get(0).([]*models.{{.Name}}), args.Get(1).(int64), args.Error(2)
}
{{end}}

// Count mocks the Count method
func (m *Mock{{.Name}}Repository) Count(ctx context.Context) (int64, error) {
	args := m.Called(ctx)
	return args.Get(0).(int64), args.Error(1)
}

// Exists mocks the Exists method
func (m *Mock{{.Name}}Repository) Exists(ctx context.Context, id uint) (bool, error) {
	args := m.Called(ctx, id)
	return args.Bool(0), args.Error(1)
}

// NewMock{{.Name}}Repository creates a new mock instance
func NewMock{{.Name}}Repository() *Mock{{.Name}}Repository {
	return &Mock{{.Name}}Repository{}
}
{{end}}

// Test helper functions

// Create{{.Name}}Fixture creates a test fixture for {{.Name}}
func Create{{.Name}}Fixture() *models.{{.Name}} {
	return &models.{{.Name}}{
		ID: 1,
		{{range .Fields}}
		{{if not .IsID}}
		// {{.Name}}: "test_{{.JsonTag}}",
		{{end}}
		{{end}}
	}
}

// Create{{.Name}}Fixtures creates multiple test fixtures
func Create{{.Name}}Fixtures(count int) []*models.{{.Name}} {
	fixtures := make([]*models.{{.Name}}, count)
	for i := 0; i < count; i++ {
		fixtures[i] = &models.{{.Name}}{
			ID: uint(i + 1),
			{{range .Fields}}
			{{if not .IsID}}
			// {{.Name}}: fmt.Sprintf("test_{{.JsonTag}}_%d", i),
			{{end}}
			{{end}}
		}
	}
	return fixtures
}

{{if .Config.Features.DTO}}
// Create{{.Name}}RequestFixture creates a test fixture for Create{{.Name}}Request
func Create{{.Name}}RequestFixture() *dto.Create{{.Name}}Request {
	return &dto.Create{{.Name}}Request{
		{{range .Fields}}
		{{if not .IsID}}
		// {{.Name}}: "test_{{.JsonTag}}",
		{{end}}
		{{end}}
	}
}

// Update{{.Name}}RequestFixture creates a test fixture for Update{{.Name}}Request
func Update{{.Name}}RequestFixture() *dto.Update{{.Name}}Request {
	{{range .Fields}}
	{{if and (not .IsID) (eq .Name "Name")}}
	name := "updated_name"
	{{end}}
	{{end}}
	return &dto.Update{{.Name}}Request{
		{{range .Fields}}
		{{if and (not .IsID) (eq .Name "Name")}}
		Name: &name,
		{{end}}
		{{end}}
	}
}
{{end}}

// AssertEqual{{.Name}} asserts two {{.Name}} objects are equal
func AssertEqual{{.Name}}(t mock.TestingT, expected, actual *models.{{.Name}}) {
	if h, ok := t.(interface{ Helper() }); ok {
		h.Helper()
	}
	
	{{range .Fields}}
	{{if not .Sensitive}}
	// assert.Equal(t, expected.{{.Name}}, actual.{{.Name}}, "{{.Name}} should match")
	{{end}}
	{{end}}
}